// Code generated by "schemagen -type MyStruct,ASlice,AMap,Basic,ABasicNested". DO NOT EDIT.

package main

import (
	"fmt"
	"github.com/metafates/schema/optional"
	"github.com/metafates/schema/required"
	validate "github.com/metafates/schema/validate"
	"time"
)

// Ensure types are not changed
func _() {
	type locked struct {
		Name  required.NonEmpty[string]  `json:"name"`
		Birth optional.InPast[time.Time] `json:"birth"`
		Anon  struct {
			Foo required.ASCII[string]
		}
		Map   map[string]required.Any[string]
		Slice [][]map[string]required.Email[string]
		Bio   string
		Ptr   *Other
		Ptr2  *[]string
	}
	// Compiler error signifies that the type definition have changed.
	// Re-run the schemagen command to regenerate this file.
	_ = locked(MyStruct{})
}

// Validate implementes [validate.Validateable]
func (x *MyStruct) Validate() error {
	err0 := validate.Validate(&x.Name)
	if err0 != nil {
		return validate.ValidationError{Inner: err0}.WithPath(fmt.Sprintf(".Name"))
	}
	err1 := validate.Validate(&x.Birth)
	if err1 != nil {
		return validate.ValidationError{Inner: err1}.WithPath(fmt.Sprintf(".Birth"))
	}
	err2 := validate.Validate(&x.Anon.Foo)
	if err2 != nil {
		return validate.ValidationError{Inner: err2}.WithPath(fmt.Sprintf(".Anon.Foo"))
	}
	for k0 := range x.Map {
		{
			v0 := x.Map[k0]
			err3 := validate.Validate(&v0)
			x.Map[k0] = v0
			if err3 != nil {
				return validate.ValidationError{Inner: err3}.WithPath(fmt.Sprintf(".Map[%v]", k0))
			}
		}
	}
	for i0 := range x.Slice {
		{
			for i1 := range x.Slice[i0] {
				{
					for k1 := range x.Slice[i0][i1] {
						{
							v1 := x.Slice[i0][i1][k1]
							err4 := validate.Validate(&v1)
							x.Slice[i0][i1][k1] = v1
							if err4 != nil {
								return validate.ValidationError{Inner: err4}.WithPath(fmt.Sprintf(".Slice[%v][%v][%v]", i0, i1, k1))
							}
						}
					}
				}
			}
		}
	}
	if x.Ptr != nil {
		{
			err5 := validate.Validate(x.Ptr)
			if err5 != nil {
				return validate.ValidationError{Inner: err5}.WithPath(fmt.Sprintf(".Ptr"))
			}
		}
	}
	return nil
}

// Ensure types are not changed
func _() {
	type locked []MyStruct
	// Compiler error signifies that the type definition have changed.
	// Re-run the schemagen command to regenerate this file.
	_ = locked(ASlice{})
}

// Validate implementes [validate.Validateable]
func (x ASlice) Validate() error {
	for i0 := range x {
		{
			err0 := validate.Validate(&x[i0])
			if err0 != nil {
				return validate.ValidationError{Inner: err0}.WithPath(fmt.Sprintf("[%v]", i0))
			}
		}
	}
	return nil
}

// Ensure types are not changed
func _() {
	type locked map[string]MyStruct
	// Compiler error signifies that the type definition have changed.
	// Re-run the schemagen command to regenerate this file.
	_ = locked(AMap{})
}

// Validate implementes [validate.Validateable]
func (x AMap) Validate() error {
	for k0 := range x {
		{
			v0 := x[k0]
			err0 := validate.Validate(&v0)
			x[k0] = v0
			if err0 != nil {
				return validate.ValidationError{Inner: err0}.WithPath(fmt.Sprintf("[%v]", k0))
			}
		}
	}
	return nil
}

// Validate implementes [validate.Validateable]
func (x *Basic) Validate() error {
	return nil
}

// Ensure types are not changed
func _() {
	type locked map[string]map[string][]string
	// Compiler error signifies that the type definition have changed.
	// Re-run the schemagen command to regenerate this file.
	_ = locked(ABasicNested{})
}

// Validate implementes [validate.Validateable]
func (x ABasicNested) Validate() error {
	return nil
}
