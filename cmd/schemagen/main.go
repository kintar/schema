package main

import (
	"cmp"
	"flag"
	"fmt"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

var flagType = flag.String("type", "", "comma-separated list of type names; must be set")

func Usage() {
	printf := func(format string, a ...any) {
		fmt.Fprintf(os.Stderr, format, a...)
	}

	printf("Schemagen is a tool to generate Go code for field-traversal validation\n")
	printf("Usage of %s:\n", os.Args[0])
	printf("\tschemagen [flags] -type T [directory]\n")
	printf("For more information, see:\n")
	printf("\thttps://github.com/metafates/schema\n")
	printf("Flags:\n")

	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("schemagen: ")

	flag.Usage = Usage
	flag.Parse()

	if len(*flagType) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	g := generator{types: strings.Split(*flagType, ",")}

	g.genPackages(args...)
}

type generator struct {
	types []string
}

// For each type, generate code in the first package where the type is declared.
// The order of packages is as follows:
// package x
// package x compiled for tests
// package x_test
//
// Each package pass could result in a separate generated file.
// These files must have the same package and test/not-test nature as the types
// from which they were generated.
//
// Types will be excluded when generated, to avoid repetitions.
func (g *generator) genPackages(patterns ...string) {
	pkgs := parsePackages(patterns...)

	slices.SortFunc(pkgs, func(a, b *packages.Package) int {
		aTest := strings.HasSuffix(a.Name, "_test")
		bTest := strings.HasSuffix(b.Name, "_test")

		if aTest != bTest {
			if !aTest {
				return -1
			}

			return 1
		}

		return cmp.Compare(len(a.GoFiles), len(b.GoFiles))
	})

	for _, pkg := range pkgs {
		g.genPackage(pkg)
	}
}

func hasTestFiles(pkg *packages.Package) bool {
	for _, f := range pkg.GoFiles {
		if strings.HasSuffix(f, "_test.go") {
			return true
		}
	}

	return false
}

func (g *generator) genPackage(pkg *packages.Package) {
	scope := pkg.Types.Scope()

	var foundTypes, remainingTypes []string

	// ensure that types exist
	for _, name := range g.types {
		if scope.Lookup(name) == nil {
			remainingTypes = append(remainingTypes, name)
		} else {
			foundTypes = append(foundTypes, name)
		}
	}

	if len(foundTypes) == 0 {
		// This package didn't have any of the relevant types, skip writing a file.
		return
	}

	if len(remainingTypes) > 0 {
		log.Fatal("cannot write to single file when matching types are found in multiple packages")
	}

	g.types = remainingTypes

	isTest := hasTestFiles(pkg)

	for _, name := range foundTypes {
		obj := scope.Lookup(name)

		f := jen.NewFilePathName(pkg.PkgPath, pkg.Name)
		f.HeaderComment("Code generated by schemagen; DO NOT EDIT.")

		genType(f, obj.Type().(*types.Named))

		var basename string

		if isTest {
			basename = name + "_schema_test.go"
		} else {
			basename = name + "_schema.go"
		}

		outputPath := filepath.Join(pkg.Dir, basename)

		if err := f.Save(outputPath); err != nil {
			log.Fatalln(err)
		}
	}
}

func parsePackages(patterns ...string) []*packages.Package {
	cfg := packages.Config{
		Mode:  packages.LoadAllSyntax,
		Tests: true, // TODO: enable
	}

	pkgs, err := packages.Load(&cfg, patterns...)
	if err != nil {
		log.Fatalln(err)
	}

	return pkgs
}

func genType(f *jen.File, named *types.Named) {
	genLock(f, named)
	genValidate(f, named)
}
